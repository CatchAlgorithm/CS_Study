### DataStructure

  - ### Array vs Linked List
    - <strong> java 에서 배열의 메모리 할당에 대해 설명해주세요.</strong>  
    
       - 자바에서 배열은 힙 영역에 실제 메모리가 할당되고, 그 메모리 주소가 스택영역에 4byte 참조형으로 할당됩니다.  
             ```int[] arr = new int[3]``` 의 경우 
           - new : 메모리를 동적으로 할당.
           - int[3] : 정수형의 3개의 요소를 담을 수 있는 12byte의 메모리를 확보한 다음 인덱스를 부여한 후 0으로 초기화
           - = : arr 변수에 메모리를 할당한 시작 주소를 넘겨줌
           - arr: 3개 요소를 인덱스로 참조할 수 있는 배열 참조 변수가 된다.
    <br>
         
    - <strong>Array 배열 끝에 요소를 삽입, 삭제할때 시간 복잡도는?</strong>
    
       -  O(1) 
    
    <br>
    
    - <strong>ArrayList가 Array에 비해 속도 측면에서 느린 이유는?</strong>
    
       - Array는 초기화시 자동 메모리 할당되지만 ArrayList는 데이터 추가 삭제시 메모리를 재할당하는 과정을 거치므로 Array보다 속도가 느림 
    
    <br>
    
    - <strong>ArrrayList 에서 특정 인덱스를 삭제했을때의 시간복잡도는?</strong>
    
       - 특정 인덱스를 가져올때 O(1)
       - 특정 인덱스에 추가할때 O(n) : 동적 자료구조이기 때문(shift)

    <br>
    
  - ### Stack and Queue
    - <strong>스택, 큐, 트리의 구조에 대해 설명해주세요.</strong>
    
      - 스택: 접시를 쌓듯이 자료를 쌓아 올린 형태의 자료 구조이다. top 위치의 원소에만 접근이 가능하고, 마지막에 삽입한 원소가 가장 먼저 삭제되는 LIFO 구조이다. 
      
      - 큐: 스택과 같이 선형 자료 구조이 FIFO 형식의 자료 구조이다. 연결리스트로 구현 할 수 있고, 줄서기 같은 것이 예이다.
      
      - 트리: 비선형 자료구조 중 하나로, 노드와 간선을 애용해 사이클을 이루지 않도록 구성한 그래프의 형태이다. 계층이 있는 데이터를 표현하기 적합하다.
             가장 기본이 되는 트리는 이진 트리 구조이고 이진 트리는 2개 이하의 자식 노드를 가진다.이진 트리는 3가지가 있다.
        - 하나의 차수로만 이루어져 있는 편향 이진트리
        - 리프 노드를 제외한 모든노드의 차수가 2개로 이루어져있는 포화 이진 트리 
        - 모든 노드가 왼쪽부터 차근차근 생성되는 완전 이진 트리  
        
        이진 탐색 트리는 탐색을 위한 이진 트리 기반의 자료구조이고, 왼쪽 노드에는 부모노드보다 작은 값이 저장되고, 오른쪽 노드에는 부모노드와 값이 같거나 큰값이 저장되는 특징이있다.
      
<br>

  - ### Tree
  
    - <strong>그래프와 트리의 방향성 차이와 간선의 수 차이</strong>
    
      - 그래프는 방향성과 간선이 있기도 하고 없기도 함  
        트리는 방향성이 있으며 n개의 노드에서는 n-1개의 간선을 가짐
        
      <br>
   
    - <strong>이진 트리에서 시간복잡도의 최악일 경우와 이유?</strong>
    
      - 한쪽으로 쏠린 경우 - O(n) Skewed Tree(편향 트리) 인 경우
      - 원소의 숫자 만큼 탐색해서 말단 노드까지 가야하므로 
   
   
      <br>
      
    - <strong> BST(Binary Search Tree)와 Binary Tree에 대해 설명?</strong>
    
      - 이진트리(Binary Tree)는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고,이진 탐색 트리(BST)는 이진 탐색과 연결 리스트를 결합한 자료구조입니다.이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 장점이 있습니다.  
        이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징이 있습니다.  
        이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일 때 시간 복잡도는 O(h)이며, 트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가집니다. 참고로 이런 worst case를 막기 위해 나온 기법이 RBT(Red-Black Tree)입니다.  
      
      <br>
      
    - <strong>이진 트리의 데이터 저장 규칙 4가지?</strong>

      - 중복된 값이 없어야 한다. 
      - 부모는 항상 자식 노드보다 커야 한다. 
      - 왼쪽 자식 노드가 오른쪽 자식 노드보다 커야 한다. 
      - 왼쪽과 오른쪽 서브트리도 이진 탐색 트리여야 한다.
      
  <br>
  
  - ### Binary Heap

    - <strong>힙과 이진 탐색 트리의 공통점, 차이점</strong>
      - 공통점
        - 힙과 이진탐색트리는 모두 이진 트리이다.

      - 차이점 
        - 힙은 각 노드의 값이 자식 노드보다 크거나 같음(max heap의 경우)
        - 이진 탐색 트리는 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드 순으로 값이 커짐
        - 힙의 자식 노드는 왼쪽이 클수도 오른쪽이 클수도 있다.

    <br>
    
    - <strong>Binary Heap에서 Max Heap과 Min Heap 설명</strong>
      - Binary Heap: 자료구조의 일종으로 Tree 의 형식을 하고 있으며, Tree 중에서도 배열에 기반한 Complete Binary Tree이다.
      - Max Heap: 부모 노드는 항상 자식 노드에 들어있는 값 보다 크다 ( 부 >= 자 )
      - Min Heap: 부모 노드는 항상 자식 노드에 들어있는 값 보다 작다 ( 부 <= 자 )
  
  <br>
  
  - ### Red Black Tree 

    - <strong>레드 블랙 트리 조건 5가지</strong>
      - 각 노드는 레드나 블랙
      - 루트 노드와 각 리프 노드(자식이 없는 노드)는 블랙
      - 자식 노드 모두 블랙이면 해당 부모 노드 레드
      - 레드 색을 가진 노드 연속으로 나올 수 없음
      - 모든 리프 노드에서 Black Depth는 같음 
    
    <br>
    
    - <strong>레드 블랙트리의 삽입 과정</strong><br>
      대표적으로 restructuring과 recoloring을 한다.<br>

      삽입된 node가 부모의 왼쪽의 노드고 부모의 형제가 블랙인 경우 오른쪽 회전 진행, 기존 노드의 색으로 변환.<br>
      삽입된 node가 부모의 오른쪽의 노드고 부모의 형제가 블랙인 경우 왼쪽 회전 진행, 기존 노드의 색으로 변환.<br>

      부모의 형제가 레드인 경우 부모와 형제의 노드를 블랙으로 바꿔주고 할아버지 노드를 레드로 바꿔준다. 만약 할아버지 노드가 루트노드라면 다시 블랙으로 바꿔준다.

    <br>
    
    - <strong>RBT 의 삽입시 최악의 시간복잡도와 상황?</strong><br>
      새로 삽입하는 노드가 빨강, 부모의 형제 노드가 빨강이면서 부모의 	부모 노드가 루트 노드가 아니어서 Double Red 가 발생할때<br>
      즉 Recoloring 이 반복적으로 일어날 때, O(logn)
     
  <br>
  
  - ### Hash Table   
    
    - <strong>java에서 hashTable과 hashMap 차이</strong>
      - HashTable만 병렬 처리와 자원 동기화 지원
    
    <br>
    
    - <strong>open addressing의 탐색 방법 3가지 설명</strong>
      - Linear Probing 선형 탐색: 현재 버킷 인덱스로부터 고정폭만큼씩 이동하여 차례대로 빈 버킷 탐색
      - Quadratic Probing 제곱 탐색: 해시의 저장순서 폭을 제곱으로 저장하는 방식
      - Double Hashing Probing 이중 해시: 해싱 값을 한번 더 해싱하는 방법
    
    <br>
    
    - <strong>해시 테이블에서 해시 충돌이 일어날 경우 해결 방법</strong>
      - 개방 주소법: 해시 충돌이 일어나면 다른 버킷에 데이터를 삽입한는 방식이다. 대표적으로 3가지 방법이있다.
        - 선형 탐색: 해시 충돌 시 다음 버킷이나 몇 개를 건너뛰어 데이터를 삽입한다.
        - 제곱 탐색: 해시 충돌 시 제곱만큼 건너뛴 버킷에 데이터를 삽입한다.
        - 이중 해시: 해시 충돌 시 다른 해시함수를 한번 더 적용한 결과를 사용한다.

      - 체이닝 : 버킷에 내에 연결 리스트를 할당하여, 같은 버킷에 데이터를 삽입해 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식이다.
    
    <br>
    
    - <strong>hash table가 최악의 상황을 가지는 경우와 해결방안 설명</strong><br>
      최악의 상황은 해시(Hash)값이 충돌하는 경우<br> 
      충돌(동일한 key 값에 복수 개의 데이터가 하나의 테이블에 존재할 수 있게 되는 것)<br>
      해시 테이블에서는 충돌에 의한 문제를 분리 연결법(Separate Chaining)과 개방 주소법(Open Addressing) 크게 2가지로 해결하고 있다.
  
      1)　추가적인 메모리를 사용하는 Chaining 방식<br>
      2）Open Addressing이란 비어있는 해시 테이블의 공간을 활용하는 방법이다.
    
    <br>
    
    - <strong>Hash Function 의 분리 연결법에 사용되는 자료구조?</strong><br>
      중복되는 해쉬에 값을 연결할때 사용하는 LinkedList 혹은 Tree 
      데이터의 갯수가 적을때 LinkedList 를 사용하는 것이 메모리 측면에서 유리하다.
  
  <br>
  
  - ### Graph
    - <strong> 연결그래프와 완전그래프의 차이점</strong>
      - 연결그래프는 무방향 그래프에서 모든 노드쌍에 대해 간선이 존재하는 그래프로 고립된 노드가 없어야 함
      - 완전그래프는 무방향 그래프에서 독립된 노드는 없어야하며 모든 노드들이 서로 연결된 그래프 (n개의 노드가 있다면 각각의 노드는 n-1개의 간선을 가져야 함)
    
    <br>
    
    - <strong>인접 리스트가 유용하게 사용되는 그래프는 어떤 그래프인지와 이유</strong>
      - 인접리스트는 그래프 내에 적은 수의 간선을 효율적으로 표현 가능한 방법이므로 간선의 수가 적은 희소 그래프에서 유용    

    <br>
    
    - <strong>다익스트라 알고리즘이란?</strong>
      - 그래프에서 여러개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단경로를 구해주는 알고리즘이다.
      
      -  특징
      
        1. 0보다 작은 값을 가지는 간선인 음의 간선이 없을 때만 정상적으로 동작한다.
        2. GPS 소프트웨어의 기본 알고리즘으로 채택된다.
        3. 매번 가장 비용이 적은 노드를 선택해서 임의의 과정을 반복하기 때문에, 그리디 알고리즘으로 분류된다.
        
        
      - 알고리즘의 원리
      
       1. 출발 노드를 설정한다.
       2. 최단 거리 테이블을 초기화한다.
       3. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택한다.
       4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단거리 테이블을 갱신한다.
       5. 3~4의 과정을 반복한다.   
    
    <br>
    
    - <strong>DFS(깊이 우선 탐색)와 BFS(넓이 우선 탐색)의 차이점</strong>
      - BFS는 우선 너비 우선 탐색도 맹목적 탐색방법 중 하나로, 시작 정점에서 시작해서 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법입니다. 선입선출(FIFO) 방식으로 동작합니다.
      - DFS는 깊이 우선 탐색은 맹목적 탐색방법의 하나로, 수평적으로 탐색한 bfs와 다르게 수직적으로 탐색을 실시합니다. dfs에서는 연결된 노드의 끝까지 탐색을 하고 역행하여 다시 탐색하지 않은 방향으로 다시 탐색하게 됩니다. DFS는 후입선출(LIFO) 방식으로 동작합니다.
    
    
    <br>
 <br>



