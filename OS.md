
### Operating System

  - ### 프로세스와 스레드의 차이
    
     - <strong>프로세스가 메모리 할당 받을 때 저장되는 힙 영역과 스택 영역의 차이점을 설명하시오</strong>
        - 힙 영역은 사용자가 직접 관리할 수 있는 메모리 영역이다. 힙 영역은 사용자에 의해 메모리공간이 동적으로 할당되고 해제된다. 
        - 스택영역은 함수의 호출과 관계되는 지역변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며, 함수의 호출이 종료될때 해제된다.

    <br>
    
    - <strong>멀티스레드의 단점?</strong>
      - 전체 프로세스에 영향을 줄 수 있다.  
      - 병목 현상으로 성능 저하가 일어날 수 있다.
      - 동기화 작업이 필요하다.
      - 교착상태가 발생하지 않도록 주의해야한다 .

    <br>
  
    - <strong>프로세스와 스레드의 차이는 무엇인가요?</strong>
      - 운영체제로부터 자원을 할당받는 작업의 단위이고, 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위 이다. 
      - 프로세스는 운영체제로부터 메모리, 주소 공간 등을 할당받고 쓰레드는 할당받은 자원들을 내부 스레드끼리 공유하면서 실행된다.
      - 프로세스는 실행 중인 프로그램으로 다른 프로세스와 상관없이 독립적으로 자원을 할당 받는다.
      - 스레드는 경량화된 프로세스로 프로세스 안에 존재한다. 각 스레드는 별도의 레지스터와 스택을 갖고, 힙 영역은 공유한다.  
  
<br>
<hr>
  
  
  - ### 멀티 스레드

    - <strong>멀티 프로세스 대신 멀티 스레드를 사용하는 이유는 무엇인지 설명하시오.</strong>
      - 1. 자원의 효율성 증대: 멀티스레드로 작업할 경우, 프로세스를 생성하여 자원을 할당하는 시스템콜이 줄어든다. 프로세스간 context switch 시, CPU 레지스터뿐만 아니라 RAM과 CPU 사이의 캐쉬까지 초기화되어 오버헤드가 크기때문.
      - 2. 스레드는 프로세스 내 메모리(stack 제외)를 공유하기 때문에 통신 비용이 적다.
      - 3. 스레드 간 context switch 시, stack만 전환하면 되므로, 전환 속도가 빠르다.

    <br>
    
    - <strong>멀티태스킹과 멀티 프로세스의 공통점과 차이점?</strong>
      - 공통점 
            -  동시에 여러작업을 수행
      - 차이점   
            - 멀티 스레드  
              - 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될수 있음
              - 스레드간의 전역변수를 공유하므로 함께 사용할때 충돌이 발생할 수 있음(동기화)
            - 멀티 프로세스  
              - 하나의 프로세스가 죽어도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행
              - 멀티 스레드보다 많은 메모르 공간과 CPU 시간을 차지
  
    <br>
    
    - <strong>멀티스레드의 단점?</strong>
      - 적은 메모리 공간을 차지하고 컨텍스트 스위칭이 빠르지만 하나의 스레드가 종료되면 전제 스레드가 종료
      - 스레드간의 전역변수를 공유하므로 함께 사용할때 충돌이 발생할 수 있음
  
    <br>
  
      - <strong>뮤텍스와 세마포어를 설명하시오</strong>
        - 뮤텍스는 상호배제라고도 하며  Lock을 사용해 하나의 프로세스나 쓰레드를 단독으로 실행하게 하는 기술
        - 세마포어는 사용중인 리소스를 잠그는데 사용되는 변수로 세마포어 변수만큼 공유자원에 프로세스가 접근 가능
    <br>
    
<br>
<hr>
  
  
  - ### 스케줄러
    - <strong>단기, 중기, 장기 스케줄러에 대해서 설명하시오.</strong>
      - 단기 스케줄러는 CPU와 메모리 사이의 스케줄링을 담당하고 장기 스케줄러는 메모리와 디스크 사이의 스케줄링을 담당한다. 중기 스케줄러는 스와핑(Swapping)을 통해 프로세스들이 CPU경쟁이 심해지는 것을 방지하는 역할을 한다.
      - 단기 스케줄러 : 준비, 실행, 대기 상태 관리
      - 중기 스케줄러 : 중단된 준비, 대기 상태 관리
      - 장기 스케줄러 : 생성 상태 관리  

        단기 스케줄러의 경우 빠르게 실행되는 프로세스들 간의 우선순위를 정하고 다시 다음 프로세스를 처리해야 하기 때문에 상당히 빨라야하고 호출 빈도수도 많다. 하지만 장기 스케줄러의 경우 새로운 Task가 들어오는 것은 단기 스케줄러에 비해 상대적으로 느리므로 호출 빈도수가 적다.
        또한 장기 스케줄러는 CPU Burst와 I/O Burst 사이의 균형을 유지해야 하므로 스케줄링 실행시간이 상대적으로 길더라도 신중하게 프로세스를 선택해야 한다. 한쪽에 지나치게 집중되면 Ready Queue와 Device Queue 중 한쪽에 치우칠 것이고 단기 스케줄러의 균형도 무너질 것이다.
    
    <br>
  
    - <strong>프로세스 스케줄러는 왜 존재하는지?</strong>
      - 프로세스들이 생성되어 실행될 때 필요한 시스템의 자원을 균등하게 할당하여 대기시간을 최소화하고 공평하게 작업을 처지하기 위해
  
<br>
<hr>
  
  
  - ### CPU 스케줄러

    - <strong>cpu 스케줄링의 종류를 설명해주세요.</strong>
      - 비선점(Non-preemptive) 스케줄링
            - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법으로, 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용한다. 일괄 처리 방식의 스케줄링으로 공정하지만 긴급 응답을 요하는 작업에 좋지 않다.

      - FCFS(FIFO) : 준비상태 큐에 도착한 순서에 따라 CPU를 할당하는 기법. 
      - SJF(Shortest Job First) : 실행시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법.
      - 우선순위(Priority) : 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법. 정적, 동적 우선순위 방법 존재


      - 선점(Preemptive) 스케줄링
            - 하나의 프로세스가 CPU를 할당받아 실행 하고 있을 때 우선순위가 높은 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
            - 선점으로 인한 많은 오버헤드가 발생한다.
            - 시분할 시스템에 사용하는 스케줄링으로 긴급을 요하는 우선순위를 갖는 시분할 처리, 실시간 처리에 유용하다.
            - 선점을 위해 시간 배당을 위한 인터럽트용 타이머 클럭(Clock)이 필요한다.

      - SRT(Shortest Remaining Time) : 현재 실행 중인 프로세스의 남은 시간과 대기 큐에 프로세스의 실행시간이 가장 짧은 프로세스에게 CPU를 할당하는 기법

      - 선점 우선순위 : 준비상태 큐의 프로세스들 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법

      - RR(Round Robin) : 시분할 시스템을 위해 고안된 방법으로, FCFS 알고리즘을 선점 형태로 변형한 기법. 대기 큐를 사용하여 먼저 대기한 작업이 먼저 CPU를 사용한다.


    <br>

    - <strong>CPU 스케줄링은 무엇이고 언제 발생하는지 설명하시오</strong>
      - CPU 하나는 동시에 여러개의 프로세스를 처리할 수 없기 때문에, 한 순간에 어떤 프로세스가 CPU를 사용할 수 있게 하는지 결정하는 정책이다. 
            - 1. 실행상태에서 대기상태로 전환될 때 (예, 입출력 요청) - Non preemptive(비선점)
            - 2. 실행상태에서 준비상태로 전환될 때 (예, 인터럽트 발생) - preemptive(선점)
            - 3. 대기상태에서 준비상태로 전환될 때(예, 입출력이 종료될 때)
            - 4. 종료될 때(Terminated)

  
<br>
<hr>
  
  
  
<br>
